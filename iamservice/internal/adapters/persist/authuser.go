package persist

import (
	"context"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/mobiletoly/gokatana-samples/iamservice/internal/adapters/persist/internal/repo"
	"github.com/mobiletoly/gokatana-samples/iamservice/internal/core/model"
	"time"

	"github.com/mobiletoly/gokatana-samples/iamservice/internal/adapters/persist/internal/mapper"
	"github.com/mobiletoly/gokatana-samples/iamservice/internal/core/outport"
	"github.com/mobiletoly/gokatana-samples/iamservice/internal/core/swagger"
	"github.com/mobiletoly/gokatana/katapp"
	"github.com/mobiletoly/gokatana/katpg"
)

// AuthUserAdapter implements the outport.AuthUserPersist outport interface
type AuthUserAdapter struct {
	db *katpg.DBLink
}

func NewAuthUserAdapter(db *katpg.DBLink) outport.AuthUserPersist {
	return &AuthUserAdapter{}
}

func (a *AuthUserAdapter) CreateUser(ctx context.Context, tx pgx.Tx, req *swagger.SignupRequest, tenantID string) (*model.AuthUser, error) {
	katapp.Logger(ctx).Info("creating user", "email", string(req.Email), "tenantID", tenantID)

	userID := uuid.NewString()
	userEntity := mapper.SwaggerSignupRequestToAuthUserEntity(req, userID, req.Password, tenantID)
	err := repo.InsertUser(ctx, tx, userEntity)
	if err != nil {
		msg := "failed to create user"
		katapp.Logger(ctx).Error(msg, "tenantID", tenantID, "error", err)
		appErr := katpg.PgToAppError(err, msg)
		if appErr.Scope == katapp.ErrDuplicate {
			return nil, katapp.NewErr(katapp.ErrDuplicate, "user with this email already exists for this tenant")
		}
		return nil, appErr
	}

	// Create empty user profile for the new user
	now := time.Now()
	profileEntity := repo.NewUserProfileEntityBuilder().
		ID(nil). // Will be auto-generated by database
		UserID(userID).
		Height(nil).
		Weight(nil).
		Gender(nil).
		BirthDate(nil).
		IsMetric(true). // Default to metric units
		CreatedAt(now).
		UpdatedAt(now).
		Build()

	_, err = repo.InsertUserProfile(ctx, tx, profileEntity)
	if err != nil {
		msg := "failed to create user profile"
		katapp.Logger(ctx).Error(msg, "userID", userID, "error", err)
		return nil, katpg.PgToAppError(err, msg)
	}

	return mapper.AuthUserEntityToAuthUserModel(userEntity), nil
}

// GetUserByEmail returns a user by email, or nil if not found
func (a *AuthUserAdapter) GetUserByEmail(ctx context.Context, tx pgx.Tx, email string, tenantID string) (*model.AuthUser, error) {
	katapp.Logger(ctx).Debug("getting user by email", "email", email, "tenantID", tenantID)

	userEntity, err := repo.SelectUserByEmail(ctx, tx, email, tenantID)
	if err != nil {
		msg := "failed to get user by email"
		katapp.Logger(ctx).Error(msg, "email", email, "tenantID", tenantID, "error", err)
		return nil, katpg.PgToAppError(err, msg)
	}
	if userEntity == nil {
		return nil, nil
	}
	return mapper.AuthUserEntityToAuthUserModel(userEntity), nil
}

// GetUserByID returns a user by ID, or nil if not found
func (a *AuthUserAdapter) GetUserByID(ctx context.Context, tx pgx.Tx, userID string) (*model.AuthUser, error) {
	katapp.Logger(ctx).Debug("getting user by ID", "userID", userID)

	userEntity, err := repo.SelectUserByID(ctx, tx, userID)
	if err != nil {
		msg := "failed to get user by ID"
		katapp.Logger(ctx).Error(msg, "userID", userID, "error", err)
		return nil, katpg.PgToAppError(err, msg)
	}
	if userEntity == nil {
		return nil, nil
	}
	return mapper.AuthUserEntityToAuthUserModel(userEntity), nil
}

func (a *AuthUserAdapter) UpdateUser(ctx context.Context, tx pgx.Tx, userID string, updates map[string]interface{}) (*model.AuthUser, error) {
	katapp.Logger(ctx).Info("updating user", "userID", userID, "updates", updates)

	err := repo.UpdateUser(ctx, tx, userID, updates)
	if err != nil {
		msg := "failed to update user"
		katapp.Logger(ctx).Error(msg, "userID", userID, "error", err)
		return nil, katpg.PgToAppError(err, msg)
	}
	return a.GetUserByID(ctx, tx, userID)
}

func (a *AuthUserAdapter) DeleteUser(ctx context.Context, tx pgx.Tx, userID string) error {
	katapp.Logger(ctx).Info("deleting user", "userID", userID)

	count, err := repo.DeleteUser(ctx, tx, userID)
	if err != nil {
		msg := "failed to delete user"
		katapp.Logger(ctx).Error(msg, "userID", userID, "error", err)
		return katpg.PgToAppError(err, msg)
	}
	if count == 0 {
		return katapp.NewErr(katapp.ErrNotFound, "user not found")
	}
	return nil
}

func (a *AuthUserAdapter) GetUserWithPasswordByEmail(ctx context.Context, tx pgx.Tx, email string, tenantID string) (*model.AuthUser, error) {
	katapp.Logger(ctx).Debug("getting user with password by email", "email", email, "tenantID", tenantID)

	userEntity, err := repo.SelectUserWithPasswordByEmail(ctx, tx, email, tenantID)
	if err != nil {
		msg := "failed to get user with password by email"
		katapp.Logger(ctx).Error(msg, "email", email, "tenantID", tenantID, "error", err)
		return nil, katpg.PgToAppError(err, msg)
	}
	if userEntity == nil {
		return nil, katapp.NewErr(katapp.ErrNotFound, "user not found")
	}
	return mapper.AuthUserEntityToAuthUserModel(userEntity), nil
}

func (a *AuthUserAdapter) GetAllUsersByTenantID(ctx context.Context, tx pgx.Tx, tenantID string) ([]*model.AuthUser, error) {
	katapp.Logger(ctx).Debug("getting all tenant users", "tenantID", tenantID)

	userEntities, err := repo.SelectAllUsersByTenantId(ctx, tx, tenantID)
	if err != nil {
		msg := "failed to get all tenant users"
		katapp.Logger(ctx).Error(msg, "tenantID", tenantID, "error", err)
		return nil, katpg.PgToAppError(err, msg)
	}

	users := make([]*model.AuthUser, len(userEntities))
	for i, entity := range userEntities {
		users[i] = mapper.AuthUserEntityToAuthUserModel(&entity)
	}
	return users, nil
}

func (a *AuthUserAdapter) GetAllUsers(ctx context.Context, tx pgx.Tx) ([]*model.AuthUser, error) {
	katapp.Logger(ctx).Debug("getting all users")

	userEntities, err := repo.SelectAllUsers(ctx, tx)
	if err != nil {
		msg := "failed to get all users"
		katapp.Logger(ctx).Error(msg, "error", err)
		return nil, katpg.PgToAppError(err, msg)
	}

	users := make([]*model.AuthUser, len(userEntities))
	for i, entity := range userEntities {
		users[i] = mapper.AuthUserEntityToAuthUserModel(&entity)
	}
	return users, nil
}

// Role management methods

func (a *AuthUserAdapter) GetUserRoles(ctx context.Context, tx pgx.Tx, userID string) ([]string, error) {
	katapp.Logger(ctx).Debug("getting user roles", "userID", userID)

	roleEntities, err := repo.SelectUserRoles(ctx, tx, userID)
	if err != nil {
		msg := "failed to get user roles"
		katapp.Logger(ctx).Error(msg, "userID", userID, "error", err)
		return nil, katpg.PgToAppError(err, "failed to select user roles")
	}

	roles := make([]string, len(roleEntities))
	for i, role := range roleEntities {
		roles[i] = role.Name
	}
	return roles, nil
}

func (a *AuthUserAdapter) AssignUserRole(ctx context.Context, tx pgx.Tx, userID string, roleName string) error {
	katapp.Logger(ctx).Info("assigning user role", "userID", userID, "roleName", roleName)

	roleEntity, err := repo.SelectRoleByName(ctx, tx, roleName)
	if err != nil {
		katapp.Logger(ctx).Error("failed to get role by name", "roleName", roleName, "error", err)
		return katpg.PgToAppError(err, "failed to select role by name")
	}

	if roleEntity == nil {
		msg := "role not found"
		katapp.Logger(ctx).Error(msg, "roleName", roleName)
		return katapp.NewErr(katapp.ErrNotFound, msg)
	}

	err = repo.InsertUserRole(ctx, tx, userID, *roleEntity.ID)
	if err != nil {
		katapp.Logger(ctx).Error("failed to assign user role", "userID", userID, "roleID", *roleEntity.ID, "error", err)
		appErr := katpg.PgToAppError(err, "failed to assign user role")
		if appErr.Scope == katapp.ErrDuplicate {
			return katapp.NewErr(katapp.ErrDuplicate, "user already has this role")
		}
		return appErr
	}
	return nil
}

func (a *AuthUserAdapter) DeleteUserRole(ctx context.Context, tx pgx.Tx, userID string, roleName string) error {
	katapp.Logger(ctx).Info("removing user role", "userID", userID, "roleName", roleName)

	roleEntity, err := repo.SelectRoleByName(ctx, tx, roleName)
	if err != nil {
		katapp.Logger(ctx).Error("failed to get role by name", "roleName", roleName, "error", err)
		return katpg.PgToAppError(err, "failed to select role by name")
	}

	if roleEntity == nil {
		katapp.Logger(ctx).Error("role not found", "roleName", roleName)
		return katapp.NewErr(katapp.ErrNotFound, "role not found")
	}

	err = repo.DeleteUserRole(ctx, tx, userID, *roleEntity.ID)
	if err != nil {
		msg := "failed to remove user role"
		katapp.Logger(ctx).Error(msg, "userID", userID, "roleID", *roleEntity.ID, "error", err)
		return katpg.PgToAppError(err, msg)
	}
	return nil
}

// Tenant operations

// GetTenantByID returns a tenant by ID, or nil if not found
func (a *AuthUserAdapter) GetTenantByID(ctx context.Context, tx pgx.Tx, tenantID string) (*model.Tenant, error) {
	katapp.Logger(ctx).Debug("getting tenant by ID", "tenantID", tenantID)

	tenantEntity, err := repo.SelectTenantByID(ctx, tx, tenantID)
	if err != nil {
		msg := "failed to get tenant by ID"
		katapp.Logger(ctx).Error(msg, "tenantID", tenantID, "error", err)
		return nil, katpg.PgToAppError(err, "failed to select tenant by ID")
	}
	if tenantEntity == nil {
		return nil, nil
	}
	return mapper.TenantEntityToTenantModel(tenantEntity), nil
}

// GetAllTenants returns all tenants
func (a *AuthUserAdapter) GetAllTenants(ctx context.Context, tx pgx.Tx) ([]*model.Tenant, error) {
	katapp.Logger(ctx).Debug("getting all tenants")

	tenantEntities, err := repo.SelectAllTenants(ctx, tx)
	if err != nil {
		katapp.Logger(ctx).Error("failed to get all tenants", "error", err)
		return nil, katpg.PgToAppError(err, "failed to select all tenants")
	}

	tenants := make([]*model.Tenant, len(tenantEntities))
	for i, entity := range tenantEntities {
		tenants[i] = mapper.TenantEntityToTenantModel(&entity)
	}
	return tenants, nil
}

// CreateTenant creates a new tenant
func (a *AuthUserAdapter) CreateTenant(ctx context.Context, tx pgx.Tx, req *swagger.TenantCreateRequest) (*model.Tenant, error) {
	katapp.Logger(ctx).Info("creating tenant", "tenantID", req.Id, "name", req.Name)

	tenantEntity := mapper.TenantCreateRequestToTenantEntity(req)
	err := repo.InsertTenant(ctx, tx, tenantEntity)
	if err != nil {
		katapp.Logger(ctx).Error("failed to create tenant", "tenantID", req.Id, "error", err)
		appErr := katpg.PgToAppError(err, "database insert failed")
		if appErr.Scope == katapp.ErrDuplicate {
			return nil, katapp.NewErr(katapp.ErrDuplicate, "tenant with this ID already exists")
		}
		return nil, appErr
	}
	return mapper.TenantEntityToTenantModel(tenantEntity), nil
}

// UpdateTenant updates an existing tenant
func (a *AuthUserAdapter) UpdateTenant(ctx context.Context, tx pgx.Tx, tenantID string, req *swagger.TenantUpdateRequest) (*model.Tenant, error) {
	katapp.Logger(ctx).Info("updating tenant", "tenantID", tenantID)

	// Check if tenant exists
	existingTenant, err := a.GetTenantByID(ctx, tx, tenantID)
	if err != nil {
		return nil, err
	}
	if existingTenant == nil {
		return nil, katapp.NewErr(katapp.ErrNotFound, "tenant not found")
	}

	tenantEntity := mapper.TenantUpdateRequestToTenantEntity(tenantID, req)
	err = repo.UpdateTenant(ctx, tx, tenantEntity)
	if err != nil {
		katapp.Logger(ctx).Error("failed to update tenant", "tenantID", tenantID, "error", err)
		appErr := katpg.PgToAppError(err, "database update failed")
		if appErr.Scope == katapp.ErrDuplicate {
			return nil, katapp.NewErr(katapp.ErrDuplicate, "tenant with this ID already exists")
		}
		return nil, appErr
	}

	// Return updated tenant
	return a.GetTenantByID(ctx, tx, tenantID)
}

// DeleteTenant deletes a tenant from the system
func (a *AuthUserAdapter) DeleteTenant(ctx context.Context, tx pgx.Tx, tenantID string) error {
	katapp.Logger(ctx).Info("deleting tenant", "tenantID", tenantID)

	rowsAffected, err := repo.DeleteTenant(ctx, tx, tenantID)
	if err != nil {
		katapp.Logger(ctx).Error("failed to delete tenant", "tenantID", tenantID, "error", err)
		return katpg.PgToAppError(err, "database delete failed")
	}
	if rowsAffected == 0 {
		return katapp.NewErr(katapp.ErrNotFound, "tenant not found")
	}
	return nil
}

// Email confirmation methods

func (a *AuthUserAdapter) CreateEmailConfirmationToken(ctx context.Context, tx pgx.Tx, userID string, email string, tokenHash string, source string, expiresAt time.Time) (*model.EmailConfirmationToken, error) {
	katapp.Logger(ctx).Info("creating email confirmation token", "userID", userID, "email", email, "source", source)

	tokenID := uuid.NewString()
	confirmationToken := model.NewEmailConfirmationTokenBuilder().
		ID(tokenID).
		UserID(userID).
		Email(email).
		TokenHash(tokenHash).
		Source(source).
		ExpiresAt(expiresAt).
		UsedAt(nil).
		CreatedAt(time.Now()).
		Build()

	err := repo.InsertEmailConfirmationToken(ctx, tx, confirmationToken)
	if err != nil {
		katapp.Logger(ctx).Error("failed to create email confirmation token", "userID", userID, "email", email, "error", err)
		return nil, katpg.PgToAppError(err, "failed to create email confirmation token")
	}

	return confirmationToken, nil
}

func (a *AuthUserAdapter) GetEmailConfirmationTokenByUserIDAndHash(ctx context.Context, tx pgx.Tx, userID string, tokenHash string) (*model.EmailConfirmationToken, error) {
	katapp.Logger(ctx).Debug("getting email confirmation token", "userID", userID)

	confirmationToken, err := repo.GetEmailConfirmationTokenByUserIDAndHash(ctx, tx, userID, tokenHash)
	if err != nil {
		katapp.Logger(ctx).Error("failed to get email confirmation token", "userID", userID, "error", err)
		return nil, katpg.PgToAppError(err, "failed to get email confirmation token")
	}

	return confirmationToken, nil
}

func (a *AuthUserAdapter) MarkEmailConfirmationTokenAsUsed(ctx context.Context, tx pgx.Tx, tokenID string) error {
	katapp.Logger(ctx).Info("marking email confirmation token as used", "tokenID", tokenID)

	err := repo.MarkEmailConfirmationTokenAsUsed(ctx, tx, tokenID)
	if err != nil {
		katapp.Logger(ctx).Error("failed to mark email confirmation token as used", "tokenID", tokenID, "error", err)
		return katpg.PgToAppError(err, "failed to mark email confirmation token as used")
	}

	return nil
}

func (a *AuthUserAdapter) SetUserEmailVerified(ctx context.Context, tx pgx.Tx, userID string, verified bool) error {
	katapp.Logger(ctx).Info("setting user email verified status", "userID", userID, "verified", verified)

	err := repo.SetUserEmailVerified(ctx, tx, userID, verified)
	if err != nil {
		katapp.Logger(ctx).Error("failed to set user email verified status", "userID", userID, "verified", verified, "error", err)
		return katpg.PgToAppError(err, "failed to set user email verified status")
	}

	return nil
}
